#!/bin/bash

#### Global Variables ####
if [ "$(uname -s)" == "Darwin" ];then
	Black='\033[0;30m'        # Black
	Red='\033[0;31m'          # Red
	Green='\033[0;32m'        # Green
	Yellow='\033[0;33m'       # Yellow
	Blue='\033[0;34m'         # Blue
	Purple='\033[0;35m'       # Purple
	Cyan='\033[0;36m'         # Cyan
	White='\033[0;37m'        # White
	# Bold
	BBlack='\033[1;30m'       # Black
	BRed='\033[1;31m'         # Red
	BGreen='\033[1;32m'       # Green
	BYellow='\033[1;33m'      # Yellow
	BBlue='\033[1;34m'        # Blue
	BPurple='\033[1;35m'      # Purple
	BCyan='\033[1;36m'        # Cyan
	BWhite='\033[1;37m'       # White
	# Background
	On_Black='\033[40m'       # Black
	On_Red='\033[41m'         # Red
	On_Green='\033[42m'       # Green
	On_Yellow='\033[43m'      # Yellow
	On_Blue='\033[44m'        # Blue
	On_Purple='\033[45m'      # Purple
	On_Cyan='\033[46m'        # Cyan
	On_White='\033[47m'       # White
	NC='\033[m'               # Color Reset
else
	Black='\e[0;30m'        # Black
	Red='\e[0;31m'          # Red
	Green='\e[0;32m'        # Green
	Yellow='\e[0;33m'       # Yellow
	Blue='\e[0;34m'         # Blue
	Purple='\e[0;35m'       # Purple
	Cyan='\e[0;36m'         # Cyan
	White='\e[0;37m'        # White
	# Bold
	BBlack='\e[1;30m'       # Black
	BRed='\e[1;31m'         # Red
	BGreen='\e[1;32m'       # Green
	BYellow='\e[1;33m'      # Yellow
	BBlue='\e[1;34m'        # Blue
	BPurple='\e[1;35m'      # Purple
	BCyan='\e[1;36m'        # Cyan
	BWhite='\e[1;37m'       # White
	# Background
	On_Black='\e[40m'       # Black
	On_Red='\e[41m'         # Red
	On_Green='\e[42m'       # Green
	On_Yellow='\e[43m'      # Yellow
	On_Blue='\e[44m'        # Blue
	On_Purple='\e[45m'      # Purple
	On_Cyan='\e[46m'        # Cyan
	On_White='\e[47m'       # White
	NC="\e[m"               # Color Reset
fi

which cowsay >&/dev/null && BIN_COW="$(which cowsay)" || BIN_COW=""
which figlet >&/dev/null && BIN_FIG="$(which figlet)" || BIN_FIG=""
which printf >&/dev/null && BIN_PRINTF="$(which printf)" || BIN_PRINTF=""
BOLD=0
COLOR_BACKGROUND=""
COLOR_FOREGROUND=""
DEBUG=0
ERR_OUT=0
LOG_NOT_STYLED=""
LOG_STYLED=""
NL=1
PNL=0
POS=0
QUIET=0
RAINBOW=0
STRING=""
STYLE=""
VERBOSITY=""

#### Functions ####
debug()
{
	(>&2 echo "BIN_COW: $BIN_COW")
	(>&2 echo "BIN_FIG: $BIN_FIG")
	(>&2 echo "BIN_PRINTF: $BIN_PRINTF")
	(>&2 echo "BOLD: $BOLD")
	(>&2 echo "COLOR_FOREGROUND: $COLOR_FOREGROUND")
	(>&2 echo "COLOR_BACKGROUND: $COLOR_BACKGROUND")
	(>&2 echo "DEBUG: $DEBUG")
	(>&2 echo "ERR_OUT: $ERR_OUT")
	(>&2 echo "LOG_STYLED: $LOG_STYLED")
	(>&2 echo "LOG_NOT_STYLED: $LOG_NOT_STYLED")
	(>&2 echo "NL: $NL")
	(>&2 echo "PNL: $PNL")
	(>&2 echo "POS: $POS")
	(>&2 echo "QUIET: $QUIET")
	(>&2 echo "STRING: $STRING")
	(>&2 echo "STYLE: $STYLE")
	(>&2 echo "RAINBOW: $RAINBOW")
	(>&2 echo "VERBOSITY: $VERBOSITY")
}
export_portable_cprint()
{
	if [ $# -lt 1 ]; then
		$0 -E -R -S "Missing template name."
		exit 1
	fi
	cat > "$1" << EOL
print()
{
	local OPTIND
	if [ "\$(uname -s)" == "Darwin" ];then
		Black='\033[0;30m'        # Black
		Red='\033[0;31m'          # Red
		Green='\033[0;32m'        # Green
		Yellow='\033[0;33m'       # Yellow
		Blue='\033[0;34m'         # Blue
		Purple='\033[0;35m'       # Purple
		Cyan='\033[0;36m'         # Cyan
		White='\033[0;37m'        # White
		# Bold
		BBlack='\033[1;30m'       # Black
		BRed='\033[1;31m'         # Red
		BGreen='\033[1;32m'       # Green
		BYellow='\033[1;33m'      # Yellow
		BBlue='\033[1;34m'        # Blue
		BPurple='\033[1;35m'      # Purple
		BCyan='\033[1;36m'        # Cyan
		BWhite='\033[1;37m'       # White
		# Background
		On_Black='\033[40m'       # Black
		On_Red='\033[41m'         # Red
		On_Green='\033[42m'       # Green
		On_Yellow='\033[43m'      # Yellow
		On_Blue='\033[44m'        # Blue
		On_Purple='\033[45m'      # Purple
		On_Cyan='\033[46m'        # Cyan
		On_White='\033[47m'       # White
		NC='\033[m'               # Color Reset
	else
		Black='\e[0;30m'        # Black
		Red='\e[0;31m'          # Red
		Green='\e[0;32m'        # Green
		Yellow='\e[0;33m'       # Yellow
		Blue='\e[0;34m'         # Blue
		Purple='\e[0;35m'       # Purple
		Cyan='\e[0;36m'         # Cyan
		White='\e[0;37m'        # White
		# Bold
		BBlack='\e[1;30m'       # Black
		BRed='\e[1;31m'         # Red
		BGreen='\e[1;32m'       # Green
		BYellow='\e[1;33m'      # Yellow
		BBlue='\e[1;34m'        # Blue
		BPurple='\e[1;35m'      # Purple
		BCyan='\e[1;36m'        # Cyan
		BWhite='\e[1;37m'       # White
		# Background
		On_Black='\e[40m'       # Black
		On_Red='\e[41m'         # Red
		On_Green='\e[42m'       # Green
		On_Yellow='\e[43m'      # Yellow
		On_Blue='\e[44m'        # Blue
		On_Purple='\e[45m'      # Purple
		On_Cyan='\e[46m'        # Cyan
		On_White='\e[47m'       # White
		NC="\e[m"               # Color Reset
	fi
	which cowsay >&/dev/null && local BIN_COW="\$(which cowsay)" || local BIN_COW=""
	which figlet >&/dev/null && local BIN_FIG="\$(which figlet)" || local BIN_FIG=""
	which printf >&/dev/null && local BIN_PRINTF="\$(which printf)" || local BIN_PRINTF=""
	local BOLD=0
	local COLOR_BACKGROUND=""
	local COLOR_FOREGROUND=""
	local DEBUG=0
	local ERR_OUT=0
	local LOG_NOT_STYLED=""
	local LOG_STYLED=""
	local NL=1
	local PNL=0
	local POS=0
	local QUIET=0
	local RAINBOW=0
	local RANDOM_COLOR=0
	local STRING=""
	local STYLE=""
	local VERBOSITY=""
	while getopts "hvTE:enpIAFcb:f:KRGYBPCWqZzL:l:S:" opt
	do
		case "\$opt" in
			"h") usage ;;
			"v") VERBOSITY="-v" && DEBUG=1;;
			"e") ERR_OUT=1 ;;
			"n") NL=0 ;;
			"p") ((PNL++)) ;;
			"I") BOLD=1 ;;
			"A") [ -f "\$BIN_COW" ] && STYLE="\$BIN_COW" ;;
			"F") [ -f "\$BIN_FIG" ] && STYLE="\$BIN_FIG" ;;
			"c") [ \$(tput cols) -le 80 ] && POS=0 || POS=\$((( \$(tput cols) - 80 ) / 2 )) ;;
			"b")
				case "\$OPTARG" in
					"black") COLOR_BACKGROUND="\$On_Black" ;;
					"red") COLOR_BACKGROUND="\$On_Red" ;;
					"green") COLOR_BACKGROUND="\$On_Green" ;;
					"yellow") COLOR_BACKGROUND="\$On_Yellow" ;;
					"blue") COLOR_BACKGROUND="\$On_Blue" ;;
					"purple") COLOR_BACKGROUND="\$On_Purple" ;;
					"cyan") COLOR_BACKGROUND="\$On_Cyan" ;;
					"white") COLOR_BACKGROUND="\$On_White" ;;
					"*") [ \$DEBUG -eq 1 ] && (>&2 echo "Unrecognized Arguement: \$OPTARG") ;;
				esac
				;;
			"f")
				case "\$OPTARG" in
					"black") [ \$BOLD -eq 0 ] && COLOR_FOREGROUND="\$Black" || COLOR_FOREGROUND="\$BBlack" ;;
					"red") [ \$BOLD -eq 0 ] && COLOR_FOREGROUND="\$Red" || COLOR_FOREGROUND="\$BRed" ;;
					"green") [ \$BOLD -eq 0 ] && COLOR_FOREGROUND="\$Green" || COLOR_FOREGROUND="\$BGreen" ;;
					"yellow") [ \$BOLD -eq 0 ] && COLOR_FOREGROUND="\$Yellow" || COLOR_FOREGROUND="\$BYellow" ;;
					"blue") [ \$BOLD -eq 0 ] && COLOR_FOREGROUND="\$Blue" || COLOR_FOREGROUND="\$BBlue" ;;
					"purple") [ \$BOLD -eq 0 ] && COLOR_FOREGROUND="\$Purple" || COLOR_FOREGROUND="\$BPurple" ;;
					"cyan") [ \$BOLD -eq 0 ] && COLOR_FOREGROUND="\$Cyan" || COLOR_FOREGROUND="\$BCyan" ;;
					"white") [ \$BOLD -eq 0 ] && COLOR_FOREGROUND="\$White" || COLOR_FOREGROUND="\$BWhite" ;;
					"*") [ \$DEBUG -eq 1 ] && (>&2 echo "Unrecognized Arguement: \$OPTARG") ;;
				esac
				;;
			"K") [ \$BOLD -eq 0 ] && COLOR_FOREGROUND="\$Black" || COLOR_FOREGROUND="\$BBlack" ;;
			"R") [ \$BOLD -eq 0 ] && COLOR_FOREGROUND="\$Red" || COLOR_FOREGROUND="\$BRed" ;;
			"G") [ \$BOLD -eq 0 ] && COLOR_FOREGROUND="\$Green" || COLOR_FOREGROUND="\$BGreen" ;;
			"Y") [ \$BOLD -eq 0 ] && COLOR_FOREGROUND="\$Yellow" || COLOR_FOREGROUND="\$BYellow" ;;
			"B") [ \$BOLD -eq 0 ] && COLOR_FOREGROUND="\$Blue" || COLOR_FOREGROUND="\$BBlue" ;;
			"P") [ \$BOLD -eq 0 ] && COLOR_FOREGROUND="\$Purple" || COLOR_FOREGROUND="\$BPurple" ;;
			"C") [ \$BOLD -eq 0 ] && COLOR_FOREGROUND="\$Cyan" || COLOR_FOREGROUND="\$BCyan" ;;
			"W") [ \$BOLD -eq 0 ] && COLOR_FOREGROUND="\$White" || COLOR_FOREGROUND="\$BWhite";;
			"q") QUIET=1;;
			"Z") RANDOM_COLOR=1 ;;
			"z") RAINBOW=1 ;;
			"L") LOG_STYLED="\$OPTARG" ;;
			"l") LOG_NOT_STYLED="\$OPTARG" ;;
			"S") STRING="\$OPTARG";;
		esac
	done
#debug()
	if [ \$DEBUG -eq 1 ]; then
		(>&2 echo "BIN_COW: \$BIN_COW")
		(>&2 echo "BIN_FIG: \$BIN_FIG")
		(>&2 echo "BIN_PRINTF: \$BIN_PRINTF")
		(>&2 echo "BOLD: \$BOLD")
		(>&2 echo "COLOR_FOREGROUND: \$COLOR_FOREGROUND")
		(>&2 echo "COLOR_BACKGROUND: \$COLOR_BACKGROUND")
		(>&2 echo "DEBUG: \$DEBUG")
		(>&2 echo "ERR_OUT: \$ERR_OUT")
		(>&2 echo "LOG_STYLED: \$LOG_STYLED")
		(>&2 echo "LOG_NOT_STYLED: \$LOG_NOT_STYLED")
		(>&2 echo "NL: \$NL")
		(>&2 echo "PNL: \$PNL")
		(>&2 echo "POS: \$POS")
		(>&2 echo "QUIET: \$QUIET")
		(>&2 echo "STRING: \$STRING")
		(>&2 echo "STYLE: \$STYLE")
		(>&2 echo "RAINBOW: \$RAINBOW")
		(>&2 echo "VERBOSITY: \$VERBOSITY")
	fi
	if [[ "\$STRING" == "" ]];then
		shift "\$((OPTIND - 1))"
		STRING="\$*"
	fi
	if [[ "\$STRING" != "" ]]; then
#process_prenl()
		while [ \$PNL -ne 0 ]
		do
			if [ \$QUIET -ne 1 ];then
				if [ -f \$BIN_PRINTF ];then
					[ \$ERR_OUT -eq 1 ] && (>&2 printf "\n") || printf "\n"
				else
					[ \$ERR_OUT -eq 1 ] && (>&2 echo "") || echo ""
				fi
			fi
			[ ! -z \${LOG_STYLED} ] && echo ""  >> "\$LOG_STYLED"
			[ ! -z \${LOG_NOT_STYLED} ] && echo ""  >> "\$LOG_NOT_STYLED"
			((PNL--))
		done
#process_string()
		string_proc="\$STRING"
		[ ! -z \${LOG_NOT_STYLED} ] && echo "\$string_proc" >> "\$LOG_NOT_STYLED"
		[ \$RAINBOW -eq 1 ] || [ \$RANDOM_COLOR -eq 1 ] && colors=( "\$Red" "\$Green" "\$Gellow" "\$Blue" "\$Purple" "\$Cyan" )
		if [ \$POS -eq 0 ]; then # Non-Centered Strings
			[ ! -z \${STYLE} ] && string_proc="\$(\$STYLE \$string_proc)" # Apply style
			[ ! -z \${COLOR_BACKGROUND} ] && string_proc="\$COLOR_BACKGROUND\$string_proc" # Apply background color
			if [ \$RAINBOW -eq 0 ]; then # rainbow not invoked, so just apply the foreground
				[ \$RANDOM_COLOR -eq 1 ] && COLOR_FOREGROUND="\${colors[\$RANDOM % \${#colors[@]}]}"
				[ ! -z \${COLOR_FOREGROUND} ] && string_proc="\$COLOR_FOREGROUND\$string_proc"
			elif [ -z \${STYLE} ]; then # Rainbow invoked. Only apply rainbow if not styled.
				string_proc_r=""
				words=(\$string_proc)
				for c in "\${words[@]}" # Loop through each word separated by spaces
				do
					COLOR_FOREGROUND="\${colors[\$RANDOM % \${#colors[@]}]}"
					[ \$DEBUG -eq 1 ] && (>&2 echo "Random seed: \$RANDOM")
					string_proc_r="\$string_proc_r\$COLOR_FOREGROUND\$c "
				done
				string_proc=\$string_proc_r\$NC # Assign final result back to string_proc
			fi
			if [ ! -z \${COLOR_FOREGROUND} ] || [ ! -z \${COLOR_BACKGROUND} ]; then
				string_proc="\$string_proc\$NC" # Append color reset if foreground/background is set.
			fi
			if [ \$QUIET -ne 1 ]; then
				if [ -f \$BIN_PRINTF ];then
					[ \$ERR_OUT -eq 1 ] && (>&2 printf -- "\$string_proc") || printf -- "\$string_proc"
				else # printf doesn't exist
					[ \$ERR_OUT -eq 1 ] && (>&2 echo "\$string_proc") || echo "\$string_proc"
				fi
			fi
		else # Centered Strings
			if [ \$QUIET -ne 1 ];then
				if [ -f \$BIN_PRINTF ];then
					[ \$ERR_OUT -eq 1 ] && (>&2 printf -- "\$COLOR_FOREGROUND\$COLOR_BACKGROUND%\$POS"s"\$NC" "\$string_proc") || printf -- "\$COLOR_FOREGROUND\$COLOR_BACKGROUND%\$POS"s"\$NC" "\$string_proc"
				else # printf doesn't exist
					[ \$ERR_OUT -eq 1 ] && (>&2 echo "\$COLOR_FOREGROUND""\$COLOR_BACKGROUND""\$string_proc""\$NC") || echo "\$COLOR_FOREGROUND""\$COLOR_BACKGROUND""\$string_proc""\$NC"
				fi
			fi
		fi
		[ ! -z \${LOG_STYLED} ] && echo -e "\$string_proc" >> "\$LOG_STYLED"
#process_nl
		if [ \$QUIET -ne 1 ]; then
			if [ \$NL -eq 1 ];then
		 		if [ -f \$BIN_PRINTF ];then
					[ \$ERR_OUT -eq 1 ] && (>&2 printf "\n") || printf "\n"
				else
					[ \$ERR_OUT -eq 1 ] && (>&2 echo "") || echo ""
				fi
			fi
		fi
	fi
}
EOL
}
usage()
{
	echo ""
	echo "	Usage for $0:"
	echo "	-h"
	echo "	[-v] -T"
	echo "	[-v] -E filename"
	echo "	[-v] [-e] [-n] [-p] [-I] [-b color] [-f color|-K|-R|-G|-Y|-B|-P|-C|-W|-Z|-z] [-L logfile] [-l logfile] -S STRING"
	echo "	[-v] [-e] [-n] [-p] [-I] [-A|-F]  [-b color] [-f color|-K|-R|-G|-Y|-B|-P|-C|-W|-Z] [-L logfile] [-l logfile] -S STRING"
	echo "	[-v] [-e] [-n] [-p] [-I] [-c] [-b color] [-f color|-K|-R|-G|-Y|-B|-P|-C|-W|-Z] [-L logfile] [-l logfile] -S STRING"
	echo ""
	echo "	-h: Display this dialog"
	echo "	-v: Enable verbosity for debugging."
	echo "	-T: Run selftest."
	echo -n "	-E filename: Export portable cprint bash function to specified file. "
	$0 -I -R -S "Warning: this will overwrite specified file."
	echo "	-e: Send output to stderr instead of stdout (default)"
	echo "	-n: Do not print newline."
	echo "	-p: Prepend newline."
	echo "	-I: Enable bold colors."
	echo "	-A: Pass text through cowsay (if it exists:$BIN_COW)"
	echo "	-F: Pass text through figlet (if it exists:$BIN_FIG)"
	echo "	-c: Center text."
	echo "	-b color: Set background."
	echo "	-f color: Set foreground."
	$0 -n -S "	[Accepted color names for -f and -b: "
	$0 -n -b white -K -S " black "
	$0 -n -R -S "red "
	$0 -n -G -S "green "
	$0 -n -Y -S "yellow "
	$0 -n -B -S "blue "
	$0 -n -P -S "purple "
	$0 -n -C -S "cyan "
	$0 -n -W -S "white"
	$0 -n -S "]"
	$0 -p -f black -b white -S "	-K: Print Black text."
	$0 -R -S "	-R: Print Red text."
	$0 -G -S "	-G: Print Green text."
	$0 -Y -S "	-Y: Print Yellow text."
	$0 -B -S "	-B: Print Blue text."
	$0 -P -S "	-P: Print Purple text."
	$0 -C -S "	-C: Print Cyan text."
	$0 -f white -b black -S "	-W: Print White text."
	$0 -Z -S "	-Z: Select a random foreground color for entire text."
	$0 -n -z -S "\t-z: Select a random foreground for each word (aka Rainbow effect)."
	$0 -I -R -S "Warning: this will eat tabs and newlines."
	echo "	-L logfile: Output to specified log file with styles."
	echo "	-l logfile: Output to specified log file without styles."
	echo "	-q: Quiet output. Don't print anything to stdout. Use in conjunction with -l and -L."
	echo "	-S string: Set the print string."
	echo ""
	exit 0
}
process_nl()
{
	if [ $QUIET -ne 1 ]; then
		if [ $NL -eq 1 ];then
	 		if [ -f $BIN_PRINTF ];then
				[ $ERR_OUT -eq 1 ] && (>&2 printf "\n") || printf "\n"
			else
				[ $ERR_OUT -eq 1 ] && (>&2 echo "") || echo ""
			fi
		fi
	fi
}
process_prenl()
{
	while [ $PNL -ne 0 ]
	do
		if [ $QUIET -ne 1 ];then
			if [ -f $BIN_PRINTF ];then
				[ $ERR_OUT -eq 1 ] && (>&2 printf "\n") || printf "\n"
			else
				[ $ERR_OUT -eq 1 ] && (>&2 echo "") || echo ""
			fi
		fi
		[ ! -z ${LOG_STYLED} ] && echo ""  >> "$LOG_STYLED"
		[ ! -z ${LOG_NOT_STYLED} ] && echo ""  >> "$LOG_NOT_STYLED"
		((PNL--))
	done
}
process_string()
{
	string_proc="$1"
	[ ! -z ${LOG_NOT_STYLED} ] && echo "$string_proc" >> "$LOG_NOT_STYLED"
	if [ $POS -eq 0 ]; then # Non-Centered Strings
		[ ! -z ${STYLE} ] && string_proc="$($STYLE $string_proc)" # Apply style
		[ ! -z ${COLOR_BACKGROUND} ] && string_proc="$COLOR_BACKGROUND$string_proc" # Apply background color
		if [ $RAINBOW -eq 0 ]; then # rainbow not invoked, so just apply the foreground
			[ ! -z ${COLOR_FOREGROUND} ] && string_proc="$COLOR_FOREGROUND$string_proc"
		elif [ -z ${STYLE} ]; then # Rainbow invoked. Only apply rainbow if not styled.
			string_proc_r=""
			words=($string_proc)
			for c in "${words[@]}" # Loop through each word separated by spaces
			do
				random_color
				string_proc_r="$string_proc_r$COLOR_FOREGROUND$c "
			done
			string_proc=$string_proc_r$NC # Assign final result back to string_proc
		fi
		if [ ! -z ${COLOR_FOREGROUND} ] || [ ! -z ${COLOR_BACKGROUND} ]; then
			string_proc="$string_proc$NC" # Append color reset if foreground/background is set.
		fi
		if [ $QUIET -ne 1 ]; then
			if [ -f $BIN_PRINTF ];then
				[ $ERR_OUT -eq 1 ] && (>&2 printf -- "$string_proc") || printf -- "$string_proc"
			else # printf doesn't exist
				[ $ERR_OUT -eq 1 ] && (>&2 echo "$string_proc") || echo "$string_proc"
			fi
		fi
	else # Centered Strings
		if [ $QUIET -ne 1 ];then
			if [ -f $BIN_PRINTF ];then
				[ $ERR_OUT -eq 1 ] && (>&2 printf -- "$COLOR_FOREGROUND$COLOR_BACKGROUND%$POS"s"$NC" "$string_proc") || printf -- "$COLOR_FOREGROUND$COLOR_BACKGROUND%$POS"s"$NC" "$string_proc"
			else # printf doesn't exist
				[ $ERR_OUT -eq 1 ] && (>&2 echo "$COLOR_FOREGROUND""$COLOR_BACKGROUND""$string_proc""$NC") || echo "$COLOR_FOREGROUND""$COLOR_BACKGROUND""$string_proc""$NC"
			fi
		fi
	fi
	[ ! -z ${LOG_STYLED} ] && echo -e "$string_proc" >> "$LOG_STYLED"
}
random_color()
{
	colors=( "$Red" "$Green" "$Gellow" "$Blue" "$Purple" "$Cyan" )
	COLOR_FOREGROUND="${colors[$RANDOM % ${#colors[@]}]}"
	[ $DEBUG -eq 1 ] && (>&2 echo "random_color: Random seed: $RANDOM")
}
selftests()
{
	$0 -E "$VERBOSITY" -c "Centered"
	$0 -E "$VERBOSITY" -F "Figlet"
	$0 -E "$VERBOSITY" -A "Cowsay"
	$0 -E "$VERBOSITY" -K "Black"
	$0 -E "$VERBOSITY" -R "Red"
	$0 -E "$VERBOSITY" -G "Green"
	$0 -E "$VERBOSITY" -Y "Yellow"
	$0 -E "$VERBOSITY" -B "Blue"
	$0 -E "$VERBOSITY" -P "Purple"
	$0 -E "$VERBOSITY" -C "Cyan"
	$0 -E "$VERBOSITY" -W "White"
	$0 -E "$VERBOSITY" -I -K "Bold Black"
	$0 -E "$VERBOSITY" -I -R "Bold Red"
	$0 -E "$VERBOSITY" -I -G "Bold Green"
	$0 -E "$VERBOSITY" -I -Y "Bold Yellow"
	$0 -E "$VERBOSITY" -I -B "Bold Blue"
	$0 -E "$VERBOSITY" -I -P "Bold Purple"
	$0 -E "$VERBOSITY" -I -C "Bold Cyan"
	$0 -E "$VERBOSITY" -I -W "Bold White"
	exit 0
}
#### Main Run ####
while getopts "hvTE:enpIAFcb:f:KRGYBPCWqZzL:l:S:" opt
do
	case "$opt" in
		"h") usage ;;
		"v") VERBOSITY="-v" && DEBUG=1;;
		"T") selftests;;
		"E") export_portable_cprint "$OPTARG";;
		"e") ERR_OUT=1 ;;
		"n") NL=0 ;;
		"p") ((PNL++)) ;;
		"I") BOLD=1 ;;
		"A") [ -f "$BIN_COW" ] && STYLE="$BIN_COW" ;;
		"F") [ -f "$BIN_FIG" ] && STYLE="$BIN_FIG" ;;
		"c") [ $(tput cols) -le 80 ] && POS=0 || POS=$((( $(tput cols) - 80 ) / 2 )) ;;
		"b")
			case "$OPTARG" in
				"black") COLOR_BACKGROUND="$On_Black" ;;
				"red") COLOR_BACKGROUND="$On_Red" ;;
				"green") COLOR_BACKGROUND="$On_Green" ;;
				"yellow") COLOR_BACKGROUND="$On_Yellow" ;;
				"blue") COLOR_BACKGROUND="$On_Blue" ;;
				"purple") COLOR_BACKGROUND="$On_Purple" ;;
				"cyan") COLOR_BACKGROUND="$On_Cyan" ;;
				"white") COLOR_BACKGROUND="$On_White" ;;
				"*") [ $DEBUG -eq 1 ] && (>&2 echo "Unrecognized Arguement: $OPTARG") ;;
			esac
			;;
		"f")
			case "$OPTARG" in
				"black") [ $BOLD -eq 0 ] && COLOR_FOREGROUND="$Black" || COLOR_FOREGROUND="$BBlack" ;;
				"red") [ $BOLD -eq 0 ] && COLOR_FOREGROUND="$Red" || COLOR_FOREGROUND="$BRed" ;;
				"green") [ $BOLD -eq 0 ] && COLOR_FOREGROUND="$Green" || COLOR_FOREGROUND="$BGreen" ;;
				"yellow") [ $BOLD -eq 0 ] && COLOR_FOREGROUND="$Yellow" || COLOR_FOREGROUND="$BYellow" ;;
				"blue") [ $BOLD -eq 0 ] && COLOR_FOREGROUND="$Blue" || COLOR_FOREGROUND="$BBlue" ;;
				"purple") [ $BOLD -eq 0 ] && COLOR_FOREGROUND="$Purple" || COLOR_FOREGROUND="$BPurple" ;;
				"cyan") [ $BOLD -eq 0 ] && COLOR_FOREGROUND="$Cyan" || COLOR_FOREGROUND="$BCyan" ;;
				"white") [ $BOLD -eq 0 ] && COLOR_FOREGROUND="$White" || COLOR_FOREGROUND="$BWhite" ;;
				"*") [ $DEBUG -eq 1 ] && (>&2 echo "Unrecognized Arguement: $OPTARG") ;;
			esac
			;;
		"K") [ $BOLD -eq 0 ] && COLOR_FOREGROUND="$Black" || COLOR_FOREGROUND="$BBlack" ;;
		"R") [ $BOLD -eq 0 ] && COLOR_FOREGROUND="$Red" || COLOR_FOREGROUND="$BRed" ;;
		"G") [ $BOLD -eq 0 ] && COLOR_FOREGROUND="$Green" || COLOR_FOREGROUND="$BGreen" ;;
		"Y") [ $BOLD -eq 0 ] && COLOR_FOREGROUND="$Yellow" || COLOR_FOREGROUND="$BYellow" ;;
		"B") [ $BOLD -eq 0 ] && COLOR_FOREGROUND="$Blue" || COLOR_FOREGROUND="$BBlue" ;;
		"P") [ $BOLD -eq 0 ] && COLOR_FOREGROUND="$Purple" || COLOR_FOREGROUND="$BPurple" ;;
		"C") [ $BOLD -eq 0 ] && COLOR_FOREGROUND="$Cyan" || COLOR_FOREGROUND="$BCyan" ;;
		"W") [ $BOLD -eq 0 ] && COLOR_FOREGROUND="$White" || COLOR_FOREGROUND="$BWhite";;
		"q") QUIET=1;;
		"Z") random_color ;;
		"z") RAINBOW=1 ;;
		"L") LOG_STYLED="$OPTARG" ;;
		"l") LOG_NOT_STYLED="$OPTARG" ;;
		"S") STRING="$OPTARG";;
	esac
done
[ $DEBUG -eq 1 ] && debug
if [[ "$STRING" == "" ]];then
	shift "$((OPTIND - 1))"
	STRING="$*"
fi
if [[ "$STRING" != "" ]]; then
	process_prenl
	process_string "$STRING"
	process_nl
fi
exit 0
